---
description: 在为PFWoTR Mod进行具体的功能规划、任务分解和进度管理时。这是最核心的PFWoTR Mod开发流程指导。
globs: 
alwaysApply: false
---
# 《开拓者：正义之怒》C# Mod 开发工作流与功能点进度追踪

本规范为《开拓者：正义之怒》(PFWoTR) 的 C# Mod 开发提供一套工作流程指导。它改编自通用C#开发规范，特别强调了Mod开发中功能分解、通过HarmonyLib进行分步Patch实现、蓝图（Blueprint）交互以及使用Unity Mod Manager (UMM) 进行集成和进度追踪的重要性。

## 1. C# 编码与 PFWoTR Modding 核心准则

*   **基本C#规范**: 遵循通用的C#命名约定 (PascalCase, camelCase)、代码布局、XML文档注释 (`///`) 和SOLID原则。参考 `[csharp_development_workflow.mdc](mdc:csharp_development_workflow.mdc)` (如果存在) 中的基础部分。
*   **游戏代码交互**: 
    *   Mod 的核心是与游戏 `Assembly-CSharp.dll` 及其他 `Owlcat.*.dll` 程序集交互。
    *   频繁使用反编译工具 (如 dnSpyEx, ILSpy) 理解游戏内部逻辑，这是定位Patch目标和数据结构的关键。
*   **日志记录 (Logging)**:
    *   优先使用 `UnityModManagerNet.UnityModManager.Logger` (`UMM.Logger.Log()`, `.Warning()`, `.Error()`) 进行日志记录，方便在UMM界面查看。
    *   对于需要与游戏自身日志系统集成的部分，可考虑使用 `Owlcat.Runtime.Core.Logging.LogChannel`。
*   **空值检查 (Null Checks)**:
    *   严格检查游戏对象实例，特别是 `Kingmaker.Game.Instance` 及其成员，以及通过 `ResourcesLibrary.TryGetBlueprint<T>()` 获取的蓝图，它们在特定游戏状态下可能为 `null`。
*   **蓝图 (Blueprints)**:
    *   理解游戏如何使用蓝图定义绝大部分内容 (法术、专长、物品、单位等)。
    *   新内容的创建通常涉及编写代码以生成新的蓝图实例 (`ScriptableObject`) 或修改现有蓝图。
    *   蓝图ID (GUID字符串) 的管理至关重要，确保Mod内部和Mod之间的唯一性。

## 2. Mod 功能点分解与分步执行 (Harmony & Blueprint 중심)

对于Mod的每个主要功能，遵循以下针对PFWoTR Modding特性的分步执行策略：

1.  **需求分析与游戏机制理解 (Requirement & Game Mechanic Analysis)**:
    *   清晰定义Mod功能要改变或添加的游戏机制。
    *   深入反编译相关游戏代码，理解原机制的实现方式、数据流和可注入点。

2.  **设计与规划 (Mod Design & Patch Planning)**:
    *   将Mod功能分解为具体的功能点，例如：某个核心方法的Patch、某个新蓝图的创建、某个UI元素的修改等。
    *   **Patch点确定**: 识别需要通过Harmony进行Patch的确切类和方法 (包括方法签名)。决定使用Prefix, Postfix, 还是Transpiler。
    *   **蓝图设计**: 如果需要新内容，设计新蓝图的结构，决定继承哪个基类蓝图，以及需要填充哪些字段。
    *   **UI变更规划**: 如果涉及UI修改，规划如何通过Patch或添加新组件来实现。
    *   **UMM设置**: 规划Mod在UMM中的设置项（如果需要）。
    *   **输出**: Mod功能点列表，每个点包含：目标Patch方法/蓝图、预期行为变更、大致实现思路。

3.  **编码实现 (Implementation - Phased & Iterative)**:
    *   **逐个功能点实现**: 
        *   **Harmony Patches**: 优先实现核心的Harmony Patches。每个Patch应尽可能独立和原子化。
        *   **Blueprint 创建/修改**: 使用代码创建和配置 `ScriptableObject` 实例作为新蓝图，或加载并修改现有蓝图。考虑使用辅助库 (如 `TabletopTweaks-Core` 的 `BlueprintInjector` 或类似工具) 注册新蓝图。
        *   **UMM 集成**: 实现 `Info.json`，UMM的 `Main` 加载函数，以及必要的设置UI逻辑。
    *   **少量多次**: 小步快跑，实现一个小功能点后立即进行游戏内测试。
    *   **代码组织**: 将Patches按目标类或功能组织在不同文件中。蓝图创建代码也可以模块化。
    *   **代码评审 (Code Review)**: 同事间对关键Patch逻辑、蓝图结构进行评审，有助于发现潜在问题和兼容性风险。

4.  **游戏内测试与验证 (In-Game Testing & Validation)**:
    *   **核心环节**: Mod开发的大部分时间应投入到游戏内测试。
    *   测试Mod在不同游戏场景下的行为：新游戏、加载旧存档、战斗中、地图上、特定剧情点等。
    *   频繁检查UMM日志和游戏日志 (`GameLog.txt`)，查找错误和警告。
    *   使用IDE附加到 `Wrath.exe` 进程进行断点调试，是定位复杂问题的有效手段。

5.  **文档与打包 (Documentation & Packaging)**:
    *   更新Mod的 `README.md`，清晰说明功能、安装方法、已知冲突和UMM设置。
    *   确保 `Info.json` 内容准确，特别是 `Id`, `Version`, `GameVersion`。
    *   按照UMM规范打包Mod (通常是包含DLL, `Info.json` 和其他资源的 .zip 文件)。

## 3. Mod功能点开发进度追踪 (PFWoTR 示例)

在项目的 `README.md` 或专门的 `MOD_PROGRESS.md` 文件中记录进度。

**示例进度记录格式 (Markdown)**:

```markdown
# Mod名称: [例如：高级法术自定义 (Advanced Spell Customization)]

## 主要功能: 允许玩家在游戏中调整法术范围和目标数量
- **状态**: 开发中
- **负责人**: @ModderX
- **目标游戏版本**: 2.1.5+
- **功能点 (Feature Points)**:
  - [x] 1. **核心逻辑Patch**: 设计并Patch `AbilityData.CalculateParams` 以允许动态修改范围和目标。
    - [x] 1.1. Harmony Prefix 添加自定义参数读取逻辑。
    - [ ] 1.2. 保存/加载自定义参数到角色存档扩展数据。
  - [ ] 2. **蓝图扩展**: 为 `BlueprintAbility` 添加新的字段用于存储玩家自定义的默认值。
    - [ ] 2.1. 使用 `[HarmonyPatch(typeof(BlueprintAbility), "AddFacts")]` (示例) 应用新组件。
  - [ ] 3. **UI集成**: 在法术书界面添加新的UI元素，允许玩家调整这些参数。
    - [ ] 3.1. Patch `SpellbookVM` 或相关UI类以注入新UI组件。
    - [ ] 3.2. 实现UI交互逻辑。
  - [ ] 4. **UMM 设置**: 添加全局开关以启用/禁用此Mod功能。
  - [ ] 5. **兼容性测试**: 与主流法术包Mod进行兼容性测试。
- **备注**: 需要研究 `Kingmaker.EntitySystem.Persistence` 如何扩展存档。

## 主要功能: 新增奥术飞弹变体
- **状态**: 待计划
- **负责人**: 待分配
- **功能点**:
  - [ ] 1. 创建新的 `BlueprintAbility` 蓝图 (ID: MyMod_ArcaneMissileVariant)
  ...
```

**进度状态**: 
*   `待计划 (To Be Planned)`
*   `设计中 (In Design)`
*   `开发中 (In Progress)`
*   `待测试 (Pending In-Game Test)`
*   `测试中 (In Test)`
*   `已完成 (Completed)`
*   `已阻塞 (Blocked)`

**定期更新**: 团队（即使是单人开发者也应自我要求）定期更新功能点进度，有助于保持开发节奏和方向。

## 4. 版本控制 (Git)

*   使用 Git，并为每个主要功能或重要修复创建独立分支 (e.g., `feature/spell-range-mod`, `fix/savegame-crash`)。
*   Commit 信息清晰描述变更内容，例如："Feat: Implement dynamic spell range adjustment via Harmony patch on CalculateParams"。

遵循此PFWoTR定制的开发规范，将有助于更有条理、更高效地完成Mod开发，并提升Mod的质量和稳定性。

