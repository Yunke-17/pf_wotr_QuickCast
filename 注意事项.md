注意事项
1.注意行动栏法术书界面和主法术书界面不是一个东西！行动栏法术书界面在游戏源码应该有ActionBar字眼，主法术书界面在游戏源码中应该有ServiceWindow字眼。
2.游戏中的行动栏法术书界面是附属在主行动栏界面上的，它在游戏中使用“**S**”表示，代表着Spellbook；与之相同的还有“**A**”表示的Ability，“**B**”表示的backage，不过后两者不是我们着重探讨的对象。
    这些“**S**”，“**A**”，“**B**”都可以通过鼠标点击的方式进行**展开/折叠**
3.如果一个角色拥有法术书，就可以打开行动栏法术书界面。（若没有法术书则隐藏“**S**”图标，代表没有法术书）
    游戏原有打开法术书并选择环位：
        ●玩家操作：点击法术书按钮或按快捷键。
        系统响应：UI显示法术书面板。默认显示0环法术，若上次打开时切换到了X环位，则显示X环书，X表示0~10的数字。
        ●玩家操作：点击环位数字（如“1”）。
        系统响应：UI请求并显示该角色1环法术列表。
4.按下某个键盘按键绑定逻辑在游戏中是不存在的。游戏中是通过鼠标长按拖拽行动栏法术书界面上的“*法术图标*”，并将图标拖拽至行动栏格子上进行替换，实现绑定功能，我们要做的就是模拟这个绑定功能，但使用键盘按键的形式。
    游戏原有拖拽法术到行动栏：
        ●玩家操作：“鼠标长按拖拽法术图标”。
        系统响应：
        UI层面：被拖拽的法术图标进入“拖拽状态”，有一个图标副本跟随鼠标。
        数据层面：系统记录下被拖拽的是哪个法术的引用。
        ●玩家操作：“拖拽至主行动栏的格子”，松开鼠标。
        系统响应：
        UI层面：如果目标格子是有效的放置区域，则法术图标“吸附”到该格子。
        数据层面：将该法术的引用（包含法术ID和所属角色ID）存储到当前行动栏Tab和页面的对应格子配置中。
        UI会立即根据这个新存储的引用刷新该格子的显示
5.模拟主行动栏也不是真正代表我们需要重新创建一个主行动栏，我们只需要利用原有的切换主行动栏进行存储信息。在游戏中玩家可以通过切换行动栏的方式来存储不同的信息，但原有的操作逻辑过于难用，只允许鼠标点击或鼠标滚轮滑动的方式，还得匹配到对应区域。这部分请结合文档中“**切换行动栏页面示例1.png**”，以及“**切换行动栏页面示例2.png**”的图片进行理解。
    游戏原有切换行动栏页面：
        ●玩家操作：点击行动栏的翻页箭头，或在指定区域滚动鼠标滚轮
        系统响应：
        UI层面：更新当前显示的页面编号（如“2/10”）。
        数据层面：系统切换到读取新Tab/页面的配置数据
        UI层面：根据新的配置数据，重新从全局库中获取信息并刷新行动栏上所有格子的显示。
6.我已经将游戏原来的Assembly-CSharp.dll文件进行反编译工作，并将反编译的代码存入到C:\Users\ToisnaLey\Desktop\C\Assembly-CSharp这个路径的文件夹中。
    对于该mod开发中任何与游戏系统交互的内容，必须查找 C:\Users\ToisnaLey\Desktop\src目录下的相关.cs反编译文件，识别相关的类、确定需要调用的方法、访问/修改的属性以及需要订阅的事件。
7.避免像拼写错误这样的低级错误的发生，请写好代码后务必注意拼写问题。
8.优先使用相对路径查询，避免查询错误。