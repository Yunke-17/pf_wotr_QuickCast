注意事项
1.注意行动栏法术书界面和主法术书界面不是一个东西！行动栏法术书界面在游戏源码应该有ActionBar字眼，主法术书界面在游戏源码中应该有ServiceWindow字眼。
2.游戏中的行动栏法术书界面是附属在主行动栏界面上的，它在游戏中使用"**S**"表示，代表着Spellbook；与之相同的还有"**A**"表示的Ability，"**B**"表示的backage，不过后两者不是我们着重探讨的对象。
    这些"**S**"，"**A**"，"**B**"都可以通过鼠标点击的方式进行**展开/折叠**
3.如果一个角色拥有法术书，就可以打开行动栏法术书界面。（若没有法术书则隐藏"**S**"图标，代表没有法术书）
    游戏原有打开法术书并选择环位：
        ●玩家操作：点击法术书按钮或按快捷键。
        系统响应：UI显示法术书面板。默认显示0环法术，若上次打开时切换到了X环位，则显示X环书，X表示0~10的数字。
        ●玩家操作：点击环位数字（如"1"）。
        系统响应：UI请求并显示该角色1环法术列表。
4.按下某个键盘按键绑定逻辑在游戏中是不存在的。游戏中是通过鼠标长按拖拽行动栏法术书界面上的"*法术图标*"，并将图标拖拽至行动栏格子上进行替换，实现绑定功能，我们要做的就是模拟这个绑定功能，但使用键盘按键的形式。
    游戏原有拖拽法术到行动栏：
        ●玩家操作："鼠标长按拖拽法术图标"。
        系统响应：
        UI层面：被拖拽的法术图标进入"拖拽状态"，有一个图标副本跟随鼠标。
        数据层面：系统记录下被拖拽的是哪个法术的引用。
        ●玩家操作："拖拽至主行动栏的格子"，松开鼠标。
        系统响应：
        UI层面：如果目标格子是有效的放置区域，则法术图标"吸附"到该格子。
        数据层面：将该法术的引用（包含法术ID和所属角色ID）存储到当前行动栏Tab和页面的对应格子配置中。
        UI会立即根据这个新存储的引用刷新该格子的显示

    **Mod的"绑定键"逻辑与游戏原生行动栏快捷键（"施法键"）的区分**：
    QuickCast Mod引入了"绑定键"的概念。这是一组由玩家在Mod设置中定义的**单个键盘按键**，例如，玩家可以将键盘"1"键设置为"绑定到逻辑槽位1的绑定键"。
    此"绑定键"（如键盘"1"）的**作用时机和上下文**与游戏原生"行动栏1"的快捷键（通常默认也是键盘"1"，Mod中称之为"施法键"）**完全不同**：
        ● **Mod的"绑定键"**：仅在**行动栏法术书界面打开，且鼠标悬停在某个法术图标上时**生效。此时按下（例如）键盘"1"这个"绑定键"，会将悬停的法术绑定到QuickCast当前环阶页的"逻辑槽位1"。
        ● **游戏的"施法键"**（行动栏快捷键）：在**快捷施法页激活并显示在主行动栏时（通常此时行动栏法术书界面是关闭的，或至少不是绑定操作的焦点）**生效。此时按下（例如）键盘"1"这个"施法键"，会施放已绑定在QuickCast"逻辑槽位1"上的法术。
    Mod需要通过代码逻辑准确判断当前的游戏状态（是否在法术书界面、是否有法术悬停等）来区分这两种对同一物理按键（如果玩家如此配置）的不同意图的响应。

    **行动栏格子触发施法的游戏原生逻辑简述**：
    当玩家按下与某个行动栏格子关联的快捷键（即Mod语境下的"施法键"）时，游戏大致会执行以下操作：
        1. 识别被按下的快捷键，并找到其对应的主行动栏格子。
        2. 获取该格子上当前承载的内容（例如一个法术 `AbilityData`，一个物品，或一个技能）。
        3. 如果内容是可用的法术 (`AbilityData`)：
            a. **检查法术目标类型** (通常通过 `AbilityData.TargetAnchor` 属性或类似机制判断)：
                i. **目标为施法者自身** (如 `AbilityTargetAnchor.Owner`)：游戏通常会直接为当前选定单位创建一个施法指令（如 `UnitUseAbility` 命令），并将其加入指令队列执行。例如 `Unit.Commands.Run(UnitUseAbility.CreateCastCommand(Spell, Caster))`。
                ii. **需要指定目标/区域** (如 `AbilityTargetAnchor.Point` 或 `AbilityTargetAnchor.Unit`)：游戏会进入一个"目标选择"模式。此时，鼠标指针可能会改变样式，玩家需要在游戏场景中点击有效的目标单位或地面位置。游戏通常会通过一个全局的处理器（如 `Game.Instance.SelectedAbilityHandler`）来管理当前待选择目标的法术，调用类似 `SelectedAbilityHandler.SetAbility(Spell)` 的方法。当玩家完成目标选择后，才会生成并执行具体的施法指令。
            b. 执行施法动画、消耗资源（法术位、施法材料等）、播放音效，并最终应用法术效果。
    QuickCast Mod在执行快速施法时，也需要模拟或调用类似上述的游戏原生施法流程，特别是要正确处理不同目标类型的法术。
5.模拟主行动栏也不是真正代表我们需要重新创建一个主行动栏，我们只需要利用原有的切换主行动栏进行存储信息。在游戏中玩家可以通过切换行动栏的方式来存储不同的信息，但原有的操作逻辑过于难用，只允许鼠标点击或鼠标滚轮滑动的方式，还得匹配到对应区域。这部分请结合文档中"**切换行动栏页面示例1.png**"，以及"**切换行动栏页面示例2.png**"的图片进行理解。
    游戏原有切换行动栏页面：
        ●玩家操作：点击行动栏的翻页箭头，或在指定区域滚动鼠标滚轮
        系统响应：
        UI层面：更新当前显示的页面编号（如"2/10"）。
        数据层面：系统切换到读取新Tab/页面的配置数据
        UI层面：根据新的配置数据，重新从全局库中获取信息并刷新行动栏上所有格子的显示。
6.我已经将游戏原来的Assembly-CSharp.dll文件进行反编译工作，并将反编译的代码存入到C:\Users\ToisnaLey\Desktop\C\Assembly-CSharp这个路径的文件夹中。
    对于该mod开发中任何与游戏系统交互的内容，必须使用desktop-commander查找 C:\Users\ToisnaLey\Desktop\src目录下的相关.cs反编译文件，识别相关的类、确定需要调用的方法、访问/修改的属性以及需要订阅的事件。
7.避免像拼写错误这样的低级错误的发生，请写好代码后务必注意拼写问题。
8.优先使用相对路径查询，避免查询错误。